%\chapter{Введение}

\chapter{Как устроена современная электроника}

Большинство современных электронных устройств представляют собой компьютеры.
То есть они работают по какой-то программе. Обычно программа наблюдает за внешним
миром и как-то реагирует на изменения в нём.

Например, <<умная>> лампочка загорается, когда становится темно.
Лифт едет после нажатия кнопки. А мобильный телефон показывает смешную
картинку, если человек нажал на правильное место на экране.

Все эти вещи кажутся очень разными, а на самом деле они очень похожи.
Внутри каждого такого устройства есть маленький или большой компьютер.
Компьютеры отличаются от других электрических и электронных устройств тем,
что работают по программе, которую можно изменить, не переделывая всё устройство
целиком.

Принципы работы всех компьютеров одинаковы: они работают с числами и программами.
Программы состоят из последовательностей простейших операций над числами, которые быстро-быстро
выполняются. Например, одним из чисел может быть температура воздуха (которую нужно измерить),
а другим --- напряжение на обогревателе, который нужно включить, если слишком холодно.
Программисты записывают эти вычисления и процесс принятия решений в виде программы,
а компьютеры затем программы выполняют.

Отличаются же компьютеры между собой тем, сколько чисел (то есть данных) они могут запоминать
и с какой скоростью обрабатывать. Ну и конечно, такими незначительными деталями,
как количество пикселей на экране или число кнопок у <<мыши>>.

\section{Двоичная система счисления}

Так уж получилось, что компьютерам и другим цифровым устройствам
удобнее всего работать в двоичной системе счисления.
Люди привыкли работать с десятичной системой, а компьютеры работают в двоичной.
И раз уж мы планируем позаниматься созданием цифровых игрушек,
компьютеров и калькуляторов, стоит изучить двоичную систему счисления
поподробнее.

Когда мы используем десятичную систему счисления, мы записываем числа с помощью десяти цифр, а у компьютеров
числа <<записаны>> (если так вообще можно говорить) с помощью только двух цифр.
Само число остаётся тем же самым независимо от формы записи. Двенадцать стульев
будут двенадцатью стульями, если их записать как $12$, $XII$ или $1100_2$.

Последний вариант это как раз двоичная запись (о чём нам намекает цифра~$2$ в конце).
В ней используется только две цифры: $1$ и $0$. И этого вполне достаточно, чтобы закодировать
любое число. $0$ записывается как $0$, $1$ будет $1$ (пока всё легко). Чтобы записать $2$
разных цифр уже не хватает, поэтому нужно использовать больше разрядов. Значит $2$ --- это $10$,
$3$ --- $11$, $4$ --- $100$, $5$ --- $101$.

Смысл тут такой же, как и в десятичном счёте. Там если разряд равен $9$ (последняя доступная цифра),
то при увеличении числа он заменяется на $0$, а более старший разряд увеличивается на единицу.
В двоичном счёте самая большая цифра это $1$, поэтому перенос происходит, когда нужно такой разряд
увеличить. Тогда при сложении $11$ и $1$ получается $100$: сначала переполняется младший разряд,
а затем из-за переноса и следующий за ним.

\subsection{Перевод числа из двоичной системы счисления}

Дальше мы будем часто встречать двоичные числа (например, наш калькулятор
будет показывать именно двоичные числа). Но как их понимать?
Как из двоичной записи получить десятичную?
Можно просто запомнить все нужные значения. Например, $1111_2=15_{10}$.
Но вдруг понадобятся числа больше чем из четырёх разрядов? Неплохо бы понять принцип.

Когда к числу добавляется ноль справа, это то же самое, что умножить исходное число на $10$.
Очевидно это так и для десятичной, и для двоичной систем счисления. Только в десятичной
$10$ это $10$, а в двоичной $10$ это $2$.

Получается, что последовательным домножением единицы на $10_2$ можно получать степени двойки:
$$1_2=2^0=1$$
$$10_2=2^1=2$$
$$100_2=2^2=4$$
$$1000_2=2^3=8$$
$$10000_2=2^4=16$$

А любое двоичное число можно разобрать на полученные выше слагаемые:

$$1101_2=1000_2+100_2+1_2=2^3+2^2+1=8+4+1=13$$

Один разряд двоичного числа называется битом. Если точнее, бит --- это единица
измерения количества информации. Он определяет одну из двух возможностей
появления взаимно исключающих событий. А если эту информацию
(выбранное событие) передать или записать где-то, то как раз можно использовать $1$ или $0$.

Два бита содержат информацию о четырёх событиях или состояниях ($00$, $01$, $10$, $11$),
три бита о восьми и так далее. Дальше мы будем в основном работать с четырёхбитными
числами, то есть от $0000$ до $1111$ (или от $0$ до $15$).

% В общем виде преобразование двоичного числа $b$, в котором много цифр, выглядит так:
% $$b_nb_{n-1}b_{n-2}\cdots b_2b_1b_0 = \sum_{i\in[0;n]}2^ib_i$$

\subsection{Перевод числа в двоичную систему счисления}

Если нам нужно в уме перевести десятичное число (например, $18$) в двоичную систему счисления,
то можно действовать так.
Сначала найти наибольшую степень двойки, которая <<помещается>> в наше число (это будет $16$).
Потом вычитаем это число из исходного, а к результату добавляем единицу в нужном разряде
(получится $2$ и $10000$).
Повторяем эти два шага снова (результатом будет $0$ и $10010$). Исходное число обнулилось,
ничего дальше делать не нужно.

Почему этот способ сработает? Не может ли дважды получиться единица в одном и том же месте?
Оказывается нет, потому что степень двойки умноженная на два (если два раза вычитать одно и то же),
это будет следующая степень двойки. А мы ведь вычитали наибольшую из возможных степеней, поэтому
такого быть не может.

Этот способ неплох, но на практике часто делают наоборот --- находят разряды результата начиная
с младшего из них. Как найти самый младший разряд? Если посмотреть на двоичную запись,
то становится очевидным, что этот разряд будет равен остатку от деления на $10_2$.
Чтобы этот разряд теперь отбросить и перейти к следующему, всё число нужно разделить на $10_2$.

Делим $18$ на $10_2=2$: младшая цифра (остаток) будет $0$, частное равно $9$.
Теперь из $9$ в результате деления получаются цифра $1$ и частное $4$.
Найденные на текущий момент цифры двоичной записи это $10$.

Теперь на входе $4$. Остаток --- $0$, частное $2$, двоичные разряды $010$.
Из $2$ получаем $0$, $1$, $0010$.

Остаётся единица, которая и становится старшим разрядом полученной двоичной записи: $10010$.

\section{Двоичная логика}

Компьютеры должны не только хранить числа, но и ещё что-то делать с ними.
Люди обычно пользуются сложением, вычитанием, умножением и делением.
Для процессора эти действия слишком сложные, поэтому они выполняются
на основе более простых операций.

Работают элементарные операции с двоичными числами. То есть у каждой на входе
одно или несколько чисел в двоичной форме, а на выходе обычно одно число
(ну и может иногда ещё пара дополнительных битов).

Простейшие операции, из которых можно построить более сложные,
вообще оперируют единичными битами. Например, два бита-операнда
на входе и один бит-результат на выходе.

Чтобы описать, как работает операция, обычно приводят
так называемую таблицу истинности. В ней для каждой комбинации значений входных
операндов ($A$ и $B$) записан результат <<вычислений>> ($R$). Примерно так:

\begin{center}
\begin{tabular}{|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{R} \\ \hline
 $0$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $1$ \\ \hline
 $0$ & $1$ & $1$ \\ \hline
 $1$ & $1$ & $1$ \\ \hline
\end{tabular}
\end{center}

Например, вторая строка таблицы означает, что если $A=1$ и $B=0$, то результатом~$R$ будет~$1$.

Вариантов таких операций (и соответственно таблиц) всего $16$ (по числу комбинаций единиц и нулей на выходе).
В реальности используются не все из них. Некоторые (самые полезные) мы сейчас рассмотрим.

Самая простая операция (или оператор) --- это отрицание. У неё только один операнд и она
меняет его значение на обратное. Записывать эту операцию мы будем как $not\ A$,
$\neg A$ или $\mbox{\textasciitilde}A$.

\begin{center}
\begin{tabular}{|c|c|}
 \hline
 \textbf{A} & \textbf{\textasciitilde A} \\ \hline
 $0$ & $1$ \\ \hline
 $1$ & $0$ \\ \hline
\end{tabular}
\end{center}

Логическое <<или>> (дизъюнкция, логическое сложение) выдаёт в качестве результата единицу,
если хотя бы один из операндов равен единице (немного отличается от обычного сложения,
потому что из~$1$ и~$1$ не получается~$2$). Обозначается такой оператор как $A\ or\ B$, $A \vee B$
или $A\ |\ B$.

\begin{center}
\begin{tabular}{|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{A | B} \\ \hline
 $0$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $1$ \\ \hline
 $0$ & $1$ & $1$ \\ \hline
 $1$ & $1$ & $1$ \\ \hline
\end{tabular}
\end{center}

Логическое <<и>> (конъюнкция, логическое умножение) выдаёт единицу только если на обоих
входах будет единица (и правда похоже на умножение). Обозначаться такой
оператор может как $A\ and\ B$, $A \wedge B$ или $A\ \mbox{\&}\ B$.

\begin{center}
\begin{tabular}{|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{A \& B} \\ \hline
 $0$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $0$ \\ \hline
 $0$ & $1$ & $0$ \\ \hline
 $1$ & $1$ & $1$ \\ \hline
\end{tabular}
\end{center}

Исключающее <<или>> (сложение по модулю~$2$, оператор неравенства) даёт нам единицу только для случаев,
когда один операнд не совпадает с другим (то есть в одном единица, а в другом ноль).
Второе название, сложение по модулю~$2$, означает, что результатом будет последняя цифра суммы операндов
(в двоичном виде, естественно).
Обозначается эта операция как $A\ xor\ B$, $A \oplus B$ или $A\ \mbox{\textasciicircum}\ B$.

\begin{center}
\begin{tabular}{|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{A \textasciicircum{} B} \\ \hline
 $0$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $1$ \\ \hline
 $0$ & $1$ & $1$ \\ \hline
 $1$ & $1$ & $0$ \\ \hline
\end{tabular}
\end{center}

С помощью этих операций компьютеры могут вычислять принимать решения вроде <<если число равно нулю>> И <<выполняется команда деления>>,
то зажечь лампочку <<ошибка>>.
Конечно, это слишком элементарные операции (да ещё и с однобитовыми числами).
Как делать что-то сложнее, например сложение или вычитание, мы узнаем позднее.

Но нельзя не упомянуть ещё одну важную операцию, на которой строятся вычисления в современных
компьютерах. Правда, в релейном конструкторе её нет, но эта технология не слишком-то современная.

Это операция <<и-не>>, то есть логическое умножение в паре с отрицанием (ещё она называется штрихом Шеффера):

\begin{center}
\begin{tabular}{|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{\textasciitilde(A \& B)} \\ \hline
 $0$ & $0$ & $1$ \\ \hline
 $1$ & $0$ & $1$ \\ \hline
 $0$ & $1$ & $1$ \\ \hline
 $1$ & $1$ & $0$ \\ \hline
\end{tabular}
\end{center}

Оказывается, с помощью этой операции (и нескольких других, но сейчас о них не будем) можно выразить любую другую.
Обозначим здесь <<и-не>> с помощью кружочка~$\circ$:

\begin{itemize}
    \item $\mbox{\textasciitilde}A = A \circ A$
    \item $A\ \mbox{\&}\ B = \mbox{\textasciitilde}(A \circ B)$
    \item $A\ |\ B = \mbox{\textasciitilde}A \circ \mbox{\textasciitilde}B$
\end{itemize}

% И так удачно совпало, что эту операцию очень легко реализовать <<в железе>>
% с помощью транзисторов (и микросхем, внутри которых тоже транзисторы).

\subsection{Задачи}

\begin{enumerate}
    \item Придумайте как вычислять <<исключающее или>> используя только <<и-не>>.
\end{enumerate}

\chapter{Элементная база компьютеров}

\section{Из чего состоит компьютер}

Мы уже поняли, что внутри компьютеров спрятано много маленьких однобитных вычислителей.
Но как компьютеру удаётся с помощью них делать что-то полезное?

Главное, что отличает компьютеры от других механизмов (или электронных устройств вроде часов) ---
это программы. Программа похожа на кулинарный рецепт: она состоит из последовательности
простых шагов. В компьютере за работу по программе отвечает процессор.
Именно он последовательно её <<читает>> и делает всё, что там написано.
Фрагменты программы (шаги, инструкции, команды) обычно очень простые. Например, сложить два числа
или вычислить <<логическое и>> (это мы уже умеем).
Так как инструкций очень-очень много, а выполняются они быстро, современный компьютер успевает за незаметное
человеческому глазу время посчитать координаты и цвета всех точек на экране, и приказать
монитору их отобразить.

Кроме процессора в компьютере есть ещё память. Там хранятся все данные пользователя
(музыка, фотографии, электронные письма), а также программы для обработки этих данных.
Программа обычно хранится в памяти как последовательность команд. Чтобы двигаться по этим командам по мере их выполнения,
нужно запоминать номер текущей. За это отвечает счётчик инструкций (program counter, instruction pointer).
Счётчик инструкций обычно находится внутри процессора.

Процессор <<смотрит>> в память на текущую инструкцию и активирует один из модулей, отвечающий за её выполнение.
Это может быть арифметическая операция, переход к другой части программы (тогда в счётчик инструкций попадает новое значение),
передача данных на внешнее устройство (вывод пикселя на экран). После всего этого счётчик инструкций переходит к следующей
команде.

Чтобы проделывать все эти шаги поочерёдно, используется тактовый генератор. Он с заданной частотой посылает
сигналы на все остальные модули, в результате чего они активируются один за другим. Например, сначала
процессор смотрит в память, потом декодирует инструкцию, то есть, разбирается с тем,
какие именно действия нужно будет выполнять дальше, а после выполнения этих действий
увеличивает счётчик инструкций.

Все числа (данные), с которыми работает процессор хранятся в памяти. Он может считывать их оттуда и записывать новые.
Но внешняя (по отношению к процессору) память обычно работает не слишком быстро, поэтому в процессоре есть несколько
регистров, используемых для вычислений. Например, процессор может сложить числа из двух регистров и записать результат
в третий. А потом другая команда отправит значение этого регистра во внешнюю память.

Мы будем строить собственный компьютер с помощью релейного конструктора.
То есть формально это будет компьютер, но он будет настолько простой, что можно даже
называть его процессором. А в качестве промежуточных этапов у нас будут получаться
ещё более простые вычислители.

В целом, компьютер можно сделать из чего угодно: из шестерёнок, реле, транзисторов,
микросхем.
Электромагнитные реле хороши тем, что сразу понятно, что они делают.
Современные компьютеры построены на транзисторах, которые упакованы в микросхемы,
но с ними не так интересно играть. Например, реле можно переключить простой отвёрткой,
а потом оценить, что изменилось.

Самое главное, что современные процессоры и компьютеры концептуально
почти не отличаются от содержимого наших занятий.
Мы будем создавать следующие части компьютера (и процессора):
\begin{enumerate}
    \item Регистры для хранения данных.
    \item Вычислительные модули для реализации команд.
    \item Память программ.
    \item Счётчик инструкций.
    \item Логические схемы для декодирования команд и выбора правильных исполнительных модулей.
    \item Тактовый генератор.
\end{enumerate}

Такой компьютер сможет выполнять простые программы, например, найти остаток от деления одного числа на другое,
используя только сложение и вычитание. А если в какой-то момент реле станет недостаточно,
полученные знания можно будет применить для разработки более сложного процессора
на современных технологиях или при программировании уже готовых устройств.

\chapter{Релейная логика}

\section{Выключатели и бинарная логика}

Первые компьютеры были построены на электромагнитных реле. А реле --- это управляемый электрическим
сигналом контакт. То есть это такие переключатели (вроде выключателей света, которыми мы пользуемся дома),
но управляемые не нажатием вручную, а с помощью электрического сигнала.

Выключатели и электрический ток в проводах очень хорошо подходят для работы с двоичным кодом.
Кнопка нажата --- значит $1$, а не нажата --- $0$. Ток течёт --- $1$, не течёт --- $0$.

Например, если на стене расположены $4$ выключателя, то с их помощью
можно закодировать четырёхбитное число. Переключив их в нужные положения
мы <<запишем>> четырёхбитное число. А посмотрев на лампочки,
соединённые с выключателями (условимся, что на выключатели смотреть нельзя),
мы можем узнать, чтоб было записано.

То есть запоминать и считывать данные мы можем. А как проводить вычисления?
Хотя бы самые простые логические операции.

Например, мы хотим выполнять логическое <<и>>: если два выключателя нажаты,
то лампочка загорается, а если хотя бы один разомкнут, лампочка гаснет.
Значит операндами являются состояния выключателей (нажаты или нет),
а результатом состояние лампочки (горит или нет).
Этого можно достичь с помощью последовательного соединения:

\begin{center}
\includegraphics{schemes/switches_and.png}
\end{center}

Слева на схеме источник напряжения, а справа <<земля>>, которая где-то за пределами рисунка
соединена с минусовым контактом источника напряжения.
Если ток будет течь слева направо через всю цепь,
от плюса к минусу, он заставит светиться лампочку <<Результат>>.
Но ток потечёт, если только оба выключателя <<Операнд 1>> и <<Операнд 2>>
будут замкнуты. Если незамкнутым выключателям сопоставить $0$, а замкнутым $1$,
то мы получим, что эта схема выполняет функции логического <<и>>.

Логическое <<или>> тоже сделать легко. Ведь ток должен течь
в цепи если любой из выключателей-операндов нажат.
Тогда соединив их параллельно мы сможем достичь такого результата:

\begin{center}
\includegraphics{schemes/switches_or.png}
\end{center}

А что будет, если мы захотим объединить несколько операций в одной схеме?
Например, выход со схемы <<или>> подать на вход схемы <<и>>.
Так как выход у нас это лампочка, а вход --- выключатель,
то придётся поставить туда человека, который будет смотреть на лампочку
и нажимать на нужный выключатель в следующей схеме.

Вот если бы лампочка сама могла <<нажимать>> на выключатель\ldots{ }
И это действительно возможно, только вместо лампочки нужно взять
электромагнит. Так мы сделаем электромагнитное реле.

\section{Электромагнитное реле}

Электромагнитное реле --- это электромагнит и один или несколько
переключателей. При прохождении тока через обмотку электромагнита он
притягивает якорь и нажимает на выключатели. С помощью этого
механизма можно передавать сигналы с выхода одной схемы на вход
другой.

На рисунке ниже схема, в которой есть одно реле (большой прямоугольник).
Внутри этого реле находится электромагнит (перечёркнутый прямоугольник)
и переключаемый контакт. К электромагниту подключена кнопка,
позволяющий подавать на него напряжение, а к переключаемому контакту реле
подключена лампочка.

\begin{center}
\includegraphics{schemes/simple_relay_off.png}
\end{center}

Когда кнопка не нажата, ничего не происходит. Ток не течёт ни через обмотку
электромагнита, ни через лампочку. Если же кнопку нажать, на электромагните
окажется напряжение и он притянет якорь и подвижную часть контакта, замкнув его.
Таким образом через эта цепь тоже замкнётся и лампочка загорится.

\begin{center}
\includegraphics{schemes/simple_relay_on.png}
\end{center}

При использовании электромагнитных реле для реализации
логических операций в качестве логической единицы обычно используется
наличие напряжения и протекание тока (цепь замкнута),
а для логического нуля --- отсутствие напряжения (цепь разомкнута).

В конструкторе применяются электромагнитные реле с четырьмя
переключающими контактами. В электрических схемах
мы используем нестандартное, но наглядное обозначение таких реле:

\begin{center}
\includegraphics{schemes/one_relay.png}
\end{center}


Контакты $13$ и $14$ подключены к катушке, управляющей состоянием контактов.
Когда напряжение на катушку не подано (и ток через неё не течёт),
контакты переключателей соединены так: $9-1$, $10-2$, $11-3$, $12-4$.

Если же реле включится, подвижная часть контактов сдвинется, разомкнув цепи,
описанные выше, и замкнув следующие: $9-5$, $10-6$, $11-7$, $12-8$.

В каждое реле конструктора встроен светодиод, поэтому можно легко увидеть,
когда оно включается. Это помогает отлаживать схемы или наблюдать
хранящиеся в релейной памяти значения.

Во всех модулях параллельно каждой из катушек реле подключён диод в обратном
направлении. Это сделано для предотвращения искрения контактов других реле
при их размыкании.
Искрение возникает из-за того, что несмотря на разрыв цепи из-за индуктивности катушки
ток должен продолжать течь какое-то время. Но из-за разрыва это невозможно
в обычном режиме, поэтому возникает электрическая дуга, постепенно разрушающая контакты.

\begin{center}
\includegraphics{schemes/diode.png}
\end{center}

Чтобы контакты меньше портились и нужен диод. Оставшийся электрический импульс проходит
уже через него, а не через разомкнутые контакты.



