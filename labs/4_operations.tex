
\chapter{Вычисления}

\section{Логические операции}

% Таблицы истинности

\section{Отрицание}

Одна из самых простых операций, которая используется в современных
компьютерах --- это операция отрицания. Она преобразует единицу
в ноль, а ноль в единицу.

Такую логику можно реализовать с помощью нормально замкнутого контакта реле:

\begin{center}
\includegraphics{schemes/not.png}
\end{center}

Когда реле выключено, ток может течь через контакт, поэтому на выходе $B$
получается единица. Если же на входе $A$ появляется единица, реле переключается
и ток через нормально замкнутый контакт не течёт. На выходе $B$ теперь ноль.

\section{Сдвиг}

Операция сдвига ещё более простая по сравнению с отрицанием.
Суть её в том, что биты в числе перемещаются по какому-либо
принципу (влево, вправо, по кругу).

В конструкторе реализован сдвиг вправо.
Нулевой бит вытесняется из числа (и может использоваться отдельно).
Первый бит становится нулевым, второй первым и так далее.
Такой сдвиг эквивалентен делению на два, поэтому деление на степень двойки в программах
процессор вычисляет с помощью инструкции сдвига.

Для реализации сдвига вправо можно даже не использовать реле:

\begin{center}
\includegraphics{schemes/shr.png}
\end{center}

В конструкторе есть готовый модуль только для сдвига вправо. Ещё в вычислениях часто используется
сдвиг влево, но его легко реализовать с помощью сложения числа с самим собой.

\section{Модуль унарных логических операций}

\begin{center}
\includegraphics{boards/logic_unary.png}
\end{center}


Модуль для унарных операций выполняет действия над $4$-битным числом: сдвиг вправо и инверсия битов.
Он имеет следующие разъёмы:
\begin{itemize}
  \item Слева и справа: шины для каскадирования нескольких модулей.
        Можно использовать, когда нужен сдвиг чисел больше четырёх бит.
  \item Сверху: разъёмы для подключения сдвигаемого операнда.
        Можно подсоединить к какой-нибудь шине, а можно к модулю переключателей или регистру.
  \item Снизу: два разъёма с выходными сигналами. На один поступает инвертированный
        операнд, а на другой сдвинутое вправо значение операнда.
\end{itemize}


\subsection{Практикум}


Список модулей:
\begin{itemize}
    \item Модуль переключателей: $2$ штуки
    \item Модуль унарных операций: $1$ штука
    \item Регистровый модуль: $1$ штука
\end{itemize}


На вход модуля унарных операций подключается модуль с тумблерами.
Выходы подключаются к шинам регистра.


\includegraphics[width=0.5\columnwidth]{photo/unary.jpg}

\begin{enumerate}
    \item Отключить все управляющие сигналы.
    \item Набрать на тумблерах со входными данными значение $1100$.
    \item Подключить выходной регистр к шине $1$. Убедиться, что в него записалось значение $0011$ (инверсия).
    \item Отключить регистр от шины, сбросить его значение.
    \item Подключить выходной регистр к шине $2$. Убедиться, что в него записалось значение $0110$ (сдвиг вправо).
\end{enumerate}

\subsection{Задачи}

\begin{enumerate}
    \item Собрать устройство, позволяющее сдвигать содержимое регистра и записывать результат обратно.
          Занести в регистр значение $1000$ и сдвигать его до тех пор, пока не получится $0001$.
          Вторую часть можно выполнять на скорость.
\end{enumerate}


\section{Логическое И}

Реле представляет собой управляемый выключатель или переключатель.
Если на один контакт $A$ выключателя подать сигнал, то на другом $C$ он появится
только если на обмотке реле $B$ есть напряжение (логическая единица).

\begin{center}
\includegraphics{schemes/and.png}
\end{center}

Получается, что на выходе выключателя сигнал будет только тогда, когда
реле включено и на входе выключателя тоже не ноль. Это означает, что такая
схема реализует операцию логическое <<И>>: $C = A \land B$.



\section{Логическое ИЛИ}


Схему для выполнения логического <<ИЛИ>> можно получить, если соединить два выхода
(две цепи). Тогда напряжение на объединённом выходе появится в любом
из вариантов, если на первом выходе единица или на втором: $C = A \lor B$.

\begin{center}
\includegraphics{schemes/or1.png}
\end{center}

Но у этого способа есть один недостаток. Если на входе $A$ окажется единица,
то так как все входы и выходы соединены в одну цепь, поданное через $A$ напряжение
будет влиять и на вход $B$. И когда $B$ используется ещё где-то,
всё заработает неправильно, какое-то реле включится.
Такой вот паразитный сигнал --- $A$ влияет на выходы, зависящие от $B$.

Поэтому иногда стоит использовать схему с реле для логического <<ИЛИ>>:

\begin{center}
\includegraphics{schemes/or2.png}
\end{center}


\section{Исключающее ИЛИ}

Схема для вычисления <<исключающего или>> несколько сложнее.
Результат операции должен равняться единице только тогда,
когда операнды не равны. То есть если на одном из входов уже
было напряжение, а потом оно появляется и на другом входе,
выход из состояния единицы должен переключиться в ноль.

Такую логику проще всего реализовать с помощью двух переключающих контактов:

\begin{center}
\includegraphics{schemes/xor.png}
\end{center}

Благодаря перекрёстному соединению переключателей проводниками,
сигнал на выходе $C$ появляется только тогда, когда переключатели на реле
находятся в противоположных положениях.

\section{Модуль бинарных логических операций}

\begin{center}
\includegraphics{boards/logic_binary.png}
\end{center}

Модуль логических операций поддерживает вычисление AND, OR и XOR.
У модуля есть два четырёхбитных входа и три выхода.
Каждый выход отвечает за одну операцию.

Модуль имеет следующие разъёмы:
\begin{itemize}
  \item Слева и справа: шины для каскадирования нескольких модулей.
        Полезных сигналов (как при сдвиге) через них не передаётся, но можно
        их использовать для фиксации нескольких логических модулей вместе,
        когда нужны более вычисления разрядностью больше четырёх бит.
  \item Сверху: разъёмы для подключения сигналов-операндов.
        Можно подсоединить к шинам, а можно к модулям переключателей или регистрам.
  \item Снизу: три разъёма с выходными сигналами: результатами вычисления
        операций И, ИЛИ, Исключающее ИЛИ.
\end{itemize}


% \subsection{Подготовка}

% \begin{enumerate}
%     \item Как могла бы выглядеть схема для выполнения операцию XOR?
% \end{enumerate}

\subsection{Практикум}

\subsubsection{Работа модуля}

Список модулей:
\begin{itemize}
    \item Модуль переключателей: $3$ штуки
    \item Модуль логических операций: $1$ штука
    \item Регистровый модуль: $1$ штука
\end{itemize}


Ко входам модуля подключаются два модуля с тумблерами, а к выходам --- регистр,
куда будет записываться результат.


\includegraphics[width=0.5\columnwidth]{photo/logic.jpg}

\begin{enumerate}
    \item Отключить все управляющие сигналы.
    \item Набрать на тумблерах первого операнда значение $1100$.
    \item Набрать на тумблерах второго операнда значение $1010$.
    \item Подключить выходной регистр к шине $1$. Убедиться, что в него записалось значение $1000$ (AND).
    \item Отключить регистр от шины, сбросить его значение.
    \item Подключить выходной регистр к шине $2$. Убедиться, что в него записалось значение $1110$ (OR).
    \item Отключить регистр от шины, сбросить его значение.
    \item Подключить выходной регистр к шине $3$. Убедиться, что в него записалось значение $0110$ (XOR).
\end{enumerate}


\subsubsection{Управление лампочкой с помощью нескольких выключателей}

Управлять одной лампочкой может быть очень полезным, если эта лампочка освещает
длинный коридор. Эту задачу можно решить с помощью механических переключателей,
но мы попробуем собрать аналогичную логическую схему.

В качестве лампочки будем использовать одно из управляющих реле регистрового модуля.
Схема должна позволять в любой момент зажечь или выключить лампочку переключением любого
из трёх тумблеров.

Построим таблицу истинности для схемы из выключателей и лампочки: входами $A$, $B$, $C$ будут
положения тумблеров, а выходом $R$ --- состояние лампочки.

Сначала всё выключена, поэтому лампочка тоже не горит:

\begin{center}
\begin{tabular}{|c|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{C} & \textbf{R} \\ \hline
 $0$ & $0$ & $0$ & $0$ \\ \hline
\end{tabular}
\end{center}

Если один из тумблеров переключить, лампочка загорится:

\begin{center}
\begin{tabular}{|c|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{C} & \textbf{R} \\ \hline
 $0$ & $0$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $0$ & $1$ \\ \hline
 $0$ & $1$ & $0$ & $1$ \\ \hline
 $0$ & $0$ & $1$ & $1$ \\ \hline
\end{tabular}
\end{center}

Потом можно выключить уже нажатый тумблер (и вернуться к первой строке таблицы),
а можно <<дойти до конца коридора>> и переключить другой. Лампочка должна погаснуть:

\begin{center}
\begin{tabular}{|c|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{C} & \textbf{R} \\ \hline
 $0$ & $0$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $0$ & $1$ \\ \hline
 $0$ & $1$ & $0$ & $1$ \\ \hline
 $0$ & $0$ & $1$ & $1$ \\ \hline
 $1$ & $1$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $1$ & $0$ \\ \hline
 $0$ & $1$ & $1$ & $0$ \\ \hline
\end{tabular}
\end{center}

И остаётся вариант, когда переключены все три тумблера. Так как число переключений нечётное,
лампочка загорается снова:

\begin{center}
\begin{tabular}{|c|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{C} & \textbf{R} \\ \hline
 $0$ & $0$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $0$ & $1$ \\ \hline
 $0$ & $1$ & $0$ & $1$ \\ \hline
 $0$ & $0$ & $1$ & $1$ \\ \hline
 $1$ & $1$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $1$ & $0$ \\ \hline
 $0$ & $1$ & $1$ & $0$ \\ \hline
 $1$ & $1$ & $1$ & $1$ \\ \hline
\end{tabular}
\end{center}

Такая таблица истинности соответствует операции <<исключающее или>>, только для трёх операндов
вместо двух. Можете убедиться самостоятельно, что таблица описывает такое выражение:

$$R = A\ xor\ B\ xor\ C = (A\ xor\ B)\ xor\ C = A\ xor\ (B\ xor\ C)$$

Чтобы его <<посчитать>> с помощью модулей конструктора нужно немного подумать.
Логический модуль считает $xor$ для пары четырёхбитных операндов. А у нас тут есть три однобитных.
То есть нужно либо взять два логических модуля, либо подавать сигнал с выхода одного
однобитного $xor$ на вход другого внутри одного и того же модуля.

Первый вариант можно реализовать с помощью такой схемы:

\includegraphics[width=\columnwidth]{photo/three_switches_xor.jpg}

Тут реализуется формула, приведённая выше: сначала выполняется $A\ xor\ B$,
а потом с полученным результатом делается $xor\ C$.
Каждый из входных битов расположен на своей плате переключателей.
Значение выходного бита показывается с помощью реле на плате регистрового модуля.

Чтобы использовать только один логический модуль, понадобится пара кросс-модулей
для перемещения битов с одного места на другое:

\includegraphics[width=\columnwidth]{photo/three_switches_xor2.jpg}

Здесь входные данные задаются с помощью трёх тумблеров: $0 - A$, $1 - B$, $2 - C$.
Все сигналы с них подаются на первый вход логического модуля. Но сигнал $B$ мы тут не используем,
а с помощью коммутационной матрицы перенаправляем его на нулевой бит второго входа логического модуля.

Получается, что нулевой бит на выходе будет равен $A\ xor\ B$. С помощью второй матрицы
мы передаём этот сигнал на второй бит второго входа. В результате второй бит будет равен
$(A\ xor\ B)\ xor\ C$, а чтобы это увидеть, к выходу $xor$ также подключен регистровый модуль с одним
управляющим реле.

\subsubsection{Игра <<Кто быстрее>>}

% кнопка для "своей игры"

% Входы ABCD
% Выходы WXYZ

% N = ~W & ~X & ~Y & ~Z
% set W = A & N

% Регистровый модуль для защелкивания результата
% Инвертор и AND для сигнала N
% AND для сигналов SET
% Модуль для размножения N

\subsubsection{Игра <<Волк, коза и капуста>>}

Тумблеры показывают положение волка, козы, капусты и человека.
Схема показывает ошибку, если позиция запрещённая.



\subsubsection{Умножение двух двухбитных чисел}

% R = A * B
% R0 = A0 & B0
% R1 = A1 & B0
% R2 = A0 & B1
% R3 = A1 & B1
% R = R0 + (R1 + R2) << 1 + R3 << 2

% R = A & B0 + (A << 1) & B1

% Логический модуль для AND
% Сумматор для получения результата
% Несколько модулей для замешивания битов

\section{Арифметические операции}

\section{Сложение}

% TODO: полусумматор

Чтобы складывать числа, сначала нужно научиться складывать отдельные биты.
Сумма двух битов может дать результат $0_2$, $1_2$ или $10_2$.
То есть при сложении получается уже двухбитовое число.

Схему сложения удобнее всего строить из однотипных компонентов, складывающих
фиксированное количество битов. На выходе такого компонента будет результат
сложения, а также бит переполнения (переноса). Для каскадирования
таких модулей нужно также иметь возможность подавать на вход перенос от
сумматоров младших битов.

Таким образом, сумматор получает на вход бит переноса и два бита-слагаемых, а на выходе
у него тоже бит переноса и однобитная сумма.

% TODO: логическое выражение для сумматора

Особенность реализации сумматора с помощью реле в том, что на входе
требуется не только перенос, но и инвертированный перенос.
Такой же инвертированный перенос можно генерировать и на выходе.

\begin{center}
\includegraphics{schemes/add.png}
\end{center}

Эту схему сумматора изобрёл Конрад Цузе для своих компьютеров в 1940х годах.
Несколько таких сумматоров можно соединить последовательно, чтобы
складывать многобитные числа. Для этого соединяются соответствующие входы
и выходы для переноса и инвертированного переноса, чтобы
переполнение переходило из бита~$0$ в бит~$1$, из бита~$1$ в бит~$2$ и
так далее.

\section{Модуль сумматора}

\begin{center}
\includegraphics{boards/adder.png}
\end{center}

Сумматор складывает два четырёхбитных числа, один бит переноса и выдаёт четырёхбитное число и бит переноса.

Модуль имеет следующие разъёмы:
\begin{itemize}
  \item Слева и справа: шины для каскадирования нескольких модулей.
        Справа к сумматору приходит сигнал переноса от младших битов (если они есть),
        а помощью шины слева получившийся в результате сложения перенос можно
        передать на следующий сумматор, записать в регистр или использовать
        в других логических схемах.
  \item Рядом с правым разъёмом есть перемычка для включения или выключения
        бита переноса, если каскадирование не используется.
        В этом случае перемычка обязательно должна быть в одном из двух положений.
        Если же справа подключен другой сумматор, то перемычку нужно убрать.
  \item Сверху: разъёмы для подключения сигналов-операндов.
        Можно подсоединить к шинам, а можно к модулям переключателей или регистрам.
  \item Снизу: разъём, откуда можно считать сумму операндов.
\end{itemize}

% \subsection{Подготовка}

% \begin{enumerate}
%     \item Придумайте, как можно было бы составить схему из реле, чтобы вычислять сумму однобитовых чисел.
%     \item Как можно использовать предыдущую схему для вычисления суммы двухбитовых чисел?
% \end{enumerate}

\subsection{Практикум}


Список модулей:
\begin{itemize}
    \item Модуль переключателей: $3$ штуки
    \item Сумматор: $1$ штука
    \item Регистровый модуль: $1$ штука
\end{itemize}

Ко входам модуля подключаются два модуля с тумблерами, а к выходам --- регистр,
куда будет записываться результат.

\includegraphics[width=0.5\columnwidth]{photo/adder.jpg}

\begin{enumerate}
    \item Отключить все управляющие сигналы.
    \item Установить перемычку для подачи сигнала на $~CY$.
    \item Набрать на тумблерах первого операнда значение $0011$ (число $3$).
    \item Набрать на тумблерах второго операнда значение $1010$ (число $10$).
    \item Подключить выходной регистр к шине $3$. Убедиться, что в него записалось значение $1101$ (число $13$).
    \item Отключить регистр от шины, сбросить его значение.
    \item Установить перемычку для подачи сигнала на $CY$.
    \item Подключить выходной регистр к шине $3$. Убедиться, что в него записалось значение $1110$ (число $14$).
\end{enumerate}


\subsection{Задачи}

\begin{enumerate}
    \item Собрать устройство для сложения значения из регистра с константой, набранной на тумблерах.
          Должна быть предусмотрена запись результата обратно в регистр.
          Дальше управлять сигналами таким образом, чтобы к регистру последовательно
          прибавлялась единица, пока он не достигнет значения $1111$.
\end{enumerate}



\section{Вычитание}

Вычитание в компьютерах делается с помощью трюков с переполнением.
Что такое $10-7=3$ в нашем четырёхбитном вычислителе?
Это $1010-0111=0011$. Так как разрядов всего $4$, тот же результат
можно получить с помощью сложения. Сначала к $10$ прибавим $5$, получив $15$
($1010+0101=1111$). Потом прибавим ещё единицу. Должно было бы получиться
$16$ ($10000$), но так как значащих битов всего $4$, пятый бит результата
пропадёт и останется значение $0$ ($0000$).

Остаётся увеличить это число на единицу ещё три раза, чтобы получился
правильный ответ. Итого, мы прибавили к $10$ число $9$ вместо вычитания $5$
и получили нужный результат.

Следовательно, вместо вычитания $7$ ($0111$) можно прибавлять $9$ ($1001$),
когда речь идёт о четырёхбитных вычислениях.

Такой же фокус можно проделать с любым числом. Быстрый алгоритм работает так:
инвертируем все биты числа, а затем прибавляем единицу. Это называется
дополнительным обратным кодом.

Например, для $0111$ сначала получится $1000$, а потом $1001$, что и требовалось.
Работает и в обратную сторону --- из $1001$ инверсией получаем $0110$,
а после добавления единицы будет $0111$.

Таким образом, для вычитания не нужно строить сложную схему, а достаточно
использовать дополнительный обратный код для второго операнда при сложении.

\section{Вычитание через сложение с дополнительным обратным кодом}

Чтобы вычесть из одного числа другое, можно вычитаемое представить в дополнительном обратном
коде, а затем сложить это число с уменьшаемым.

Число в дополнительном обратном коде получается, если сначала инвертировать биты исходного
числа, а затем прибавить к нему единицу.

Например, для числа $3=0011$ инверсия будет выглядеть, как $1100$, а дополнительный обратный код, как $1101$.

\subsubsection{Практикум}


Список модулей:
\begin{itemize}
    \item Модуль переключателей: $3$ штуки
    \item Сумматор: $1$ штука
    \item Регистровый модуль: $1$ штука
\end{itemize}

Собрать схему для сложения.

\begin{enumerate}
    \item Отключить все управляющие сигналы.
    \item Установить перемычку для подачи сигнала на $~CY$.
    \item Набрать на тумблерах первого операнда значение $1010$ (число $10$).
    \item Набрать на тумблерах второго операнда значение $1101$ (число $-3$).
    \item Подключить выходной регистр к шине $3$. Убедиться, что в него записалось значение $0111$ (число $7$).
\end{enumerate}

\subsubsection{Задачи}
\begin{enumerate}
    \item Выполните деление в столбик числа $14$ на $3$ с помощью последовательности вычитаний.
          Записывайте промежуточные результаты на бумаге.
    \item Сделайте то же самое, только сохраняйте все промежуточные результаты в разных
          регистрах регистрового файла.
\end{enumerate}

\section{Вычитание с помощью сумматора и инвертора}

Вычитание можно делать с помощью сумматора. Чтобы на входе из операнда получался дополнительный
обратный код, сначала нужно преобразовать его с помощью инвертора, а затем прибавить $1$,
включив вход переноса в сумматоре.

\subsubsection{Практикум}


Список модулей:
\begin{itemize}
    \item Модуль переключателей: $3$ штуки
    \item Модуль унарных операций: $1$ штука
    \item Сумматор: $1$ штука
    \item Регистровый модуль: $1$ штука
\end{itemize}

Собрать схему для сложения, а затем добавить между тумблерами со вторым операндом
инвертор (выход NOT блока унарной логики):

\includegraphics[width=0.5\columnwidth]{photo/subtractor.jpg}

\begin{enumerate}
    \item Отключить все управляющие сигналы.
    \item Установить перемычку для подачи сигнала на $CY$.
    \item Набрать на тумблерах первого операнда значение $1010$ (число $10$).
    \item Набрать на тумблерах второго операнда значение $0011$ (число $3$).
    \item Подключить выходной регистр к шине $3$. Убедиться, что в него записалось значение $0111$ (число $7$).
\end{enumerate}
