%\chapter{Введение}

\chapter{Компьютер --- это вычислитель}



\section{Двоичная система счисления}

Так уж получилось, что компьютерам удобнее всего работать в двоичной системе счисления.
Люди привыкли работать с десятичной системой, а компьютеры работают в двоичной.
Это значит, что мы записываем числа с помощью десяти цифр, а у компьютеров
числа <<записаны>> (если так вообще можно говорить) с помощью только двух цифр.

Само число остаётся тем же самым независимо от формы записи. Двенадцать стульев
будут двенадцатью стульями, если их записать как $12$, $XII$ или $1100_2$.

Последний вариант это как раз двоичная запись (о чём нам намекает цифра~$2$ в конце).
В ней используется только две цифры: $1$ и $0$. И этого вполне достаточно, чтобы закодировать
любое число. $0$ записывается как $0$, $1$ будет $1$ (пока всё легко). Чтобы записать $2$
разных цифр уже не хватает, поэтому нужно использовать больше разрядов. Значит $2$ --- это $10$,
$3$ --- $11$, $4$ --- $100$, $5$ --- $101$.

Смысл тут такой же, как и в десятичном счёте. Там если разряд равен $9$ (последняя доступная цифра),
то при увеличении числа он заменяется на $0$, а более старший разряд увеличивается на единицу.
В двоичном счёте самая большая цифра это $1$, поэтому перенос происходит, когда нужно такой разряд
увеличить. Тогда при сложении $11$ и $1$ получается $100$: сначала переполняется младший разряд,
а затем из-за переноса и следующий за ним.

\subsection{Перевод числа из двоичной системы счисления}

Дальше мы будем часто встречать двоичные числа. Но как их понимать?
Как из двоичной записи получить десятичную?
Можно просто запомнить все нужные значения. Например, $1111_2=15_{10}$.
Но вдруг понадобятся числа больше чем из четырёх разрядов? Неплохо бы понять принцип.

Когда к числу добавляется ноль справа, это то же самое, что умножить исходное число на $10$.
Очевидно это так и для десятичной, и для двоичной систем счисления. Только в десятичной
$10$ это $10$, а в двоичной $10$ это $2$.

Получается, что последовательным домножением единицы на $10_2$ можно получать степени двойки:
$$1_2=2^0=1$$
$$10_2=2^1=2$$
$$100_2=2^2=4$$
$$1000_2=2^3=8$$
$$10000_2=2^4=16$$

А любое двоичное число можно разобрать на полученные выше слагаемые:

$$1101_2=1000_2+100_2+1_2=2^3+2^2+1=8+4+1=13$$

В общем виде преобразование двоичного числа $b$, в котором много цифр, выглядит так:
$$b_nb_{n-1}b_{n-2}\cdots b_2b_1b_0 = \sum_{i\in[0;n]}2^ib_i$$

\subsection{Перевод числа в двоичную систему счисления}

Если нам нужно в уме перевести десятичное число (например, $18$) в двоичную систему счисления,
то можно действовать так.
Сначала найти наибольшую степень двойки, которая <<помещается>> в наше число (это будет $16$).
Потом вычитаем это число из исходного, а к результату добавляем единицу в нужном разряде
(получится $2$ и $10000$).
Повторяем эти два шага снова (результатом будет $0$ и $10010$). Исходное число обнулилось,
ничего дальше делать не нужно.

Почему этот способ сработает? Не может ли дважды получиться единица в одном и том же месте?
Оказывается нет, потому что степень двойки умноженная на два (если два раза вычитать одно и то же),
это будет следующая степень двойки. А мы ведь вычитали наибольшую из возможных степеней, поэтому
такого быть не может.

Этот способ неплох, но на практике часто делают наоборот --- находят разряды результата начиная
с младшего из них. Как найти самый младший разряд? Если посмотреть на двоичную запись,
то становится очевидным, что этот разряд будет равен остатку от деления на $10_2$.
Чтобы этот разряд теперь отбросить и перейти к следующему, всё число нужно разделить на $10_2$.

Делим $18$ на $10_2=2$: младшая цифра (остаток) будет $0$, частное равно $9$.
Теперь из $9$ в результате деления получаются цифра $1$ и частное $4$.
Найденные на текущий момент цифры двоичной записи это $10$.

Теперь на входе $4$. Остаток --- $0$, частное $2$, двоичные разряды $010$.
Из $2$ получаем $0$, $1$, $0010$.

Остаётся единица, которая и становится старшим разрядом полученной двоичной записи: $10010$.

\section{Двоичная логика}

Компьютеры должны не только хранить числа, но и ещё что-то делать с ними.
Люди обычно пользуются сложением, вычитанием, умножением и делением.
Для компьютера эти действия слишком сложные, поэтому они выполняются
на основе более простых операций.

Работают все эти операции с двоичными числами. То есть у каждой на входе
одно или несколько чисел в двоичной форме, а на выходе обычно одно число
(ну и может иногда ещё пара дополнительных битов).

Простейшие операции, из которых можно построить более сложные,
вообще оперируют единичными битами. Например, два бита-операнда
на входе и один бит-результат на выходе.

Чтобы описать, как работает операция, обычно приводят
так называемую таблицу истинности. В ней для каждой комбинации значений входных
операндов ($A$ и $B$) записан результат <<вычислений>> ($R$). Примерно так:

\begin{center}
\begin{tabular}{|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{R} \\ \hline
 $0$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $1$ \\ \hline
 $0$ & $1$ & $1$ \\ \hline
 $1$ & $1$ & $1$ \\ \hline
\end{tabular}
\end{center}

Вариантов таких операций всего $16$ (по числу комбинаций единиц и нулей на выходе).
В реальности используются не все из них. Некоторые (самые полезные) мы сейчас рассмотрим.

Самая простая операция --- это отрицание. У неё только один операнд и она
меняет его значение на обратное. Записывать эту операцию мы будем как $not\ A$,
$\neg A$ или $\mbox{\textasciitilde}A$.

\begin{center}
\begin{tabular}{|c|c|}
 \hline
 \textbf{A} & \textbf{\textasciitilde A} \\ \hline
 $0$ & $1$ \\ \hline
 $1$ & $0$ \\ \hline
\end{tabular}
\end{center}

Логическое <<или>> (дизъюнкция, логическое сложение) выдаёт в качестве результата единицу,
если хотя бы один из операндов равен единице. Обозначается такой оператор как $A\ or\ B$, $A \vee B$
или $A\ |\ B$.

\begin{center}
\begin{tabular}{|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{A | B} \\ \hline
 $0$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $1$ \\ \hline
 $0$ & $1$ & $1$ \\ \hline
 $1$ & $1$ & $1$ \\ \hline
\end{tabular}
\end{center}

Логическое <<и>> (конъюнкция, логическое умножение) выдаёт единицу только если на обоих
входах будет единица (и правда похоже на умножение). Обозначаться такой
оператор может как $A\ and\ B$, $A \wedge B$ или $A\ \mbox{\&}\ B$.

\begin{center}
\begin{tabular}{|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{A \& B} \\ \hline
 $0$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $0$ \\ \hline
 $0$ & $1$ & $0$ \\ \hline
 $1$ & $1$ & $1$ \\ \hline
\end{tabular}
\end{center}

Исключающее <<или>> (сложение по модулю $2$, оператор неравенства) даёт нам единицу только для случаев,
когда один операнд не совпадает с другим (то есть в одном единица, а в другом ноль).
Обозначается эта операция как $A\ xor\ B$, $A \oplus B$ или $A\ \mbox{\textasciicircum}\ B$.

\begin{center}
\begin{tabular}{|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{A \textasciicircum{} B} \\ \hline
 $0$ & $0$ & $0$ \\ \hline
 $1$ & $0$ & $1$ \\ \hline
 $0$ & $1$ & $1$ \\ \hline
 $1$ & $1$ & $0$ \\ \hline
\end{tabular}
\end{center}

С помощью этих операций компьютеры могут вычислять принимать решения вроде <<если число равно нулю>> И <<выполняется команда деления>>,
то зажечь лампочку <<ошибка>>.
Конечно, это слишком элементарные операции (да ещё и с однобитовыми числами).
Как делать что-то сложнее, например сложение или вычитание, мы узнаем позднее.

Но нельзя не упомянуть ещё одну важную операцию, на которой строятся вычисления в современных
компьютерах. Правда, в релейном конструкторе её нет, но эта технология не слишком-то современная.

Это операция <<и-не>>, то есть логическое умножение в паре с отрицанием (ещё она называется штрихом Шеффера):

\begin{center}
\begin{tabular}{|c|c|c|}
 \hline
 \textbf{A} & \textbf{B} & \textbf{\textasciitilde(A \& B)} \\ \hline
 $0$ & $0$ & $1$ \\ \hline
 $1$ & $0$ & $1$ \\ \hline
 $0$ & $1$ & $1$ \\ \hline
 $1$ & $1$ & $0$ \\ \hline
\end{tabular}
\end{center}

Оказывается, с помощью этой операции (и нескольких других, но сейчас о них не будем) можно выразить любую другую.
Обозначим здесь <<и-не>> с помощью кружочка~$\circ$:

\begin{itemize}
    \item $\mbox{\textasciitilde}A = A \circ A$
    \item $A\ \mbox{\&}\ B = \mbox{\textasciitilde}(A \circ B)$
    \item $A\ |\ B = \mbox{\textasciitilde}A \circ \mbox{\textasciitilde}B$
\end{itemize}

И так удачно совпало, что эту операцию очень легко реализовать <<в железе>>
с помощью транзисторов (и микросхем, внутри которых тоже транзисторы).

\subsection{Задачи}

\begin{enumerate}
    \item Придумайте как вычислять <<исключающее или>> используя только <<и-не>>.
\end{enumerate}

\chapter{Элементная база компьютеров}

\section{Из чего состоит компьютер}

Мы уже поняли, что внутри компьютеров спрятано много маленьких однобитных вычислителей.
Но как компьютеру удаётся с помощью них делать что-то полезное?

Главное, что отличает компьютеры от других механизмов (или электронных устройств вроде часов) ---
это программы. Программа похожа на кулинарный рецепт: она состоит из последовательности
простых шагов. В случае компьютера эти шаги (инструкции, команды) очень простые. Например, сложить два числа
или вычислить <<логическое и>> (это мы уже умеем).
Так как инструкций очень-очень много, а выполняются они быстро, современный компьютер успевает за незаметное
человеческому глазу время посчитать координаты и цвета всех точек на экране, и приказать
монитору их отобразить.

Программа обычно хранится в памяти как последовательность команд. Чтобы двигаться по этим командам по мере их выполнения,
нужно запоминать номер текущей. За это отвечает счётчик инструкций (program counter, instruction pointer).
Счётчик инструкций --- это часть процессора, который собственно всё и делает.

Процессор <<смотрит>> в память на текущую инструкцию и активирует один из модулей, отвечающий за её выполнение.
Это может быть арифметическая операция, переход к другой части программы (тогда в счётчик инструкций попадает новое значение),
передача данных на внешнее устройство (вывод пикселя на экран). После всего этого счётчик инструкций переходит к следующей
команде.

Чтобы проделывать все эти шаги поочерёдно, используется тактовый генератор. Он с заданной частотой посылает
сигналы на все остальные модули, в результате чего они активируются один за другим. Например, сначала
процессор смотрит в память, потом декодирует инструкцию, а в конце увеличивает счётчик инструкций.

Все числа (данные), с которыми работает процессор хранятся в памяти. Он может считывать их оттуда и записывать новые.
Но внешняя (по отношению к процессору) память обычно работает не слишком быстро, поэтому в процессоре есть несколько
регистров, используемых для вычислений. Например, процессор может сложить числа из двух регистров и записать результат
в третий. А потом другая команда отправит значение этого регистра во внешнюю память.

Мы будем строить свой компьютер с помощью релейного конструктора.
При этом будем создавать следующие части компьютера (и процессора):
\begin{enumerate}
    \item Регистры для хранения данных.
    \item Вычислительные модули для реализации команд.
    \item Память программ.
    \item Счётчик инструкций.
    \item Логические схемы для декодирования команд и выбора правильных исполнительных модулей.
    \item Тактовый генератор.
\end{enumerate}

Такой компьютер сможет выполнять простые программы, например, найти остаток от деления одного числа на другое,
используя только сложение и вычитание.

\chapter{Релейная логика}

\section{Выключатели и бинарная логика}

Первые компьютеры были построены на электромагнитных реле. А реле --- это управляемый электрическим
сигналом контакт. То есть это такие переключатели (вроде выключателей света, которыми мы пользуемся дома),
но управляемые не нажатием вручную, а с помощью электрического сигнала.

\section{Электромагнитное реле}

В конструкторе используются электромагнитные реле с четырьмя
переключающими контактами. В электрических схемах
мы используем нестандартное, но наглядное обозначение таких реле:

\begin{center}
\includegraphics{schemes/one_relay.png}
\end{center}


Контакты $13$ и $14$ подключены к катушке, управляющей состоянием контактов.
Когда напряжение на катушку не подано (и ток через неё не течёт),
контакты переключателей соединены так: $9-1$, $10-2$, $11-3$, $12-4$.

Если же реле включится, подвижная часть контактов сдвинется, разомкнув цепи,
описанные выше, и замкнув следующие: $9-5$, $10-6$, $11-7$, $12-8$.

В каждое реле конструктора встроен светодиод, поэтому можно легко увидеть,
когда оно включается. Это помогает отлаживать схемы или наблюдать
хранящиеся в релейной памяти значения.

Во всех модулях параллельно каждой из катушек реле подключён диод в обратном
направлении. Это сделано для предотвращения искрения контактов других реле
при их размыкании.
Искрение возникает из-за того, что несмотря на разрыв цепи из-за индуктивности катушки
ток должен продолжать течь какое-то время. Но из-за разрыва это невозможно
в обычном режиме, поэтому возникает электрическая дуга, постепенно разрушающая контакты.

\begin{center}
\includegraphics{schemes/diode.png}
\end{center}

Чтобы контакты меньше портились и нужен диод. Оставшийся электрический импульс проходит
уже через него, а не через разомкнутые контакты.

\section{Логические уровни}

При использовании электромагнитных реле логической единице соответствует
наличие напряжения (цепь замкнута), а логическому нулю --- отсутствие напряжения
(цепь разомкнута).


\chapter{Релейный конструктор}

\section{Модули}

\section{Соединительные шины}

