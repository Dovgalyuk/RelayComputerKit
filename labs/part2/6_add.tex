\chapter{Арифметические операции. Сложение}

\section{Как складывать двоичные числа}

Логическое сложение мы уже видели. Там $1+1=1$, это не подходит для того,
чтобы делать обычные арифметические вычисления. Ведь мы хотим получить
$1_2+1_2=10_2$.

Посмотрим, как складывать два числа, например $14$ и $7$.
Для этого переведём их в двоичную систему счисления (всё равно ведь компьютеры работают в ней)
и запишем их для сложения в столбик:

$$
\begin{array}{ccccc}
  & 1 & 1 & 1 & 0 \\
+ & 0 & 1 & 1 & 1 \\ \hline
  & ? & ? & ? & ? \\
\end{array}
$$

Сложение в столбик как обычно делается справа налево. Только здесь ещё нужно помнить,
что мы работаем в двоичной, а не в десятичной системе счисления.
Справа складываются $0$ и $1$, очевидно, что получается $1$:

$$
\begin{array}{ccccc}
  & 1 & 1 & 1 & 0 \\
+ & 0 & 1 & 1 & 1 \\ \hline
  & ? & ? & ? & 1 \\
\end{array}
$$

Следующая пара цифр это $1$ и $1$. Мы уже знаем, что должно получиться~$10$.
А это значит, что в текущем разряде остаётся~$0$, а лишняя единица должна перейти
в следующий разряд:

$$
\begin{array}{ccccc}
  & 1 & 1 & 1 & 0 \\
+ & 0 & 1 & 1 & 1 \\ \hline
  & ? & ?+1 & 0 & 1 \\
\end{array}
$$

Дальше мы снова складываем $1$ и $1$, но к ним ещё добавляется перенос из предыдущего разряда.
То есть будет $1+1+1=11$. Значит в текущем разряде результата теперь единица,
а в следующий снова идёт бит переноса.

$$
\begin{array}{ccccc}
  & 1 & 1 & 1 & 0 \\
+ & 0 & 1 & 1 & 1 \\ \hline
  & ?+1 & 1 & 0 & 1 \\
\end{array}
$$

Последняя сумма уже знакома: $1+0+1=10$. То есть в текущий разряд результата записывается~$0$,
а в следующий идёт~$1$.

$$
\begin{array}{ccccc}
  & 1 & 1 & 1 & 0 \\
+ & 0 & 1 & 1 & 1 \\ \hline
1 & 0 & 1 & 0 & 1 \\
\end{array}
$$

Если перевести $10101_2$ в десятичную систему, то получится $16+4+1=21$, как и ожидалось.
Теперь нужно придумать, как такую сумму считать с помощью реле.

\section{Сумматор}

Чтобы складывать числа, сначала нужно научиться складывать отдельные биты.
Сумма двух битов может дать результат $0_2$, $1_2$ или $10_2$.
То есть при сложении получается уже двухбитовое число.

Схему сложения удобнее всего строить из однотипных компонентов, складывающих
пару битов. На выходе такого компонента будет результат
сложения, а также бит переноса (он же бит переполнения или carry или CY). Для каскадирования
таких модулей нужно также иметь возможность подавать на вход перенос от
сумматоров младших битов.

Таким образом, сумматор получает на вход бит переноса и два бита-слагаемых, а на выходе
у него тоже бит переноса и однобитная сумма. С помощью набора таких сумматоров можно
сложить числа любой длины.

% TODO: логическое выражение для сумматора

Особенность реализации сумматора с помощью реле в том, что на входе
требуется не только перенос, но и инвертированный перенос.
Такой же инвертированный перенос можно генерировать и на выходе.

\begin{center}
\includegraphics{schemes/add.png}
\end{center}

Эту схему сумматора изобрёл Конрад Цузе для своих компьютеров в 1940х годах.
Несколько таких сумматоров можно соединить последовательно, чтобы
складывать многобитные числа. Для этого соединяются соответствующие входы
и выходы для переноса и инвертированного переноса, чтобы
переполнение переходило из бита~$0$ в бит~$1$, из бита~$1$ в бит~$2$ и
так далее.

\section{Модуль сумматора}

\includegraphics[width=\columnwidth]{schemes_components/adder.png}


\begin{center}
\includegraphics{boards/adder.png}
\end{center}

Сумматор складывает два четырёхбитных числа, один бит переноса и выдаёт четырёхбитное число и бит переноса.

Модуль имеет следующие разъёмы:
\begin{itemize}
  \item Слева и справа: шины для каскадирования нескольких модулей.
        Справа к сумматору приходит сигнал переноса от сумматора младших битов (если он подключен),
        а помощью шины слева получившийся в результате сложения перенос можно
        передать на следующий сумматор, записать в регистр или использовать
        в других логических схемах.
  \item Рядом с правым разъёмом есть перемычка для включения или выключения
        бита переноса, если каскадирование не используется.
        В этом случае перемычка обязательно должна быть в одном из двух положений.
        Если же справа подключен другой сумматор, то перемычку нужно убрать.
        Без перемычки (или без замены её тумблерами) не получится, потому что один
        из двух сигналов (перенос или инвертированный перенос) должен быть единицей.
  \item Сверху: разъёмы для подключения сигналов-операндов.
        Можно подсоединить к шинам, а можно к модулям переключателей или регистрам.
  \item Снизу: разъём, откуда можно считать сумму операндов.
\end{itemize}

% \subsection{Подготовка}

% \begin{enumerate}
%     \item Придумайте, как можно было бы составить схему из реле, чтобы вычислять сумму однобитовых чисел.
%     \item Как можно использовать предыдущую схему для вычисления суммы двухбитовых чисел?
% \end{enumerate}

\section{Практикум}

\subsection{Работа модуля}

Список модулей:
\begin{itemize}
    \item Модуль переключателей: $3$ штуки
    \item Сумматор: $1$ штука
    \item Регистровый модуль: $1$ штука
\end{itemize}

Ко входам модуля подключаются два модуля с тумблерами, а к выходам --- регистр,
куда будет записываться результат.

\includegraphics[width=0.5\columnwidth]{photo/adder.jpg}

\begin{enumerate}
    \item Отключить все управляющие сигналы.
    \item Установить перемычку для подачи сигнала на $\textasciitilde CY$.
    \item Набрать на тумблерах первого операнда значение $0011$ (число $3$).
    \item Набрать на тумблерах второго операнда значение $1010$ (число $10$).
    \item Подключить выходной регистр к шине $3$. Убедиться, что в него записалось значение $1101$ (число $13$).
    \item Отключить регистр от шины, сбросить его значение.
    \item Установить перемычку для подачи сигнала на $CY$.
    \item Подключить выходной регистр к шине $3$. Убедиться, что в него записалось значение $1110$ (число $14$).
\end{enumerate}


\subsection{Умножение двух двухбитных чисел}

Глава у нас про сложение, но здесь мы увидим, как с помощью сумматора
выполнять операцию умножения.
Схемы для умножения чисел получаются намного сложнее схем для сложения,
поэтому такого модуля в конструкторе нет.
Посмотрим, что получится, когда мы умножаем два двухбитных числа
$a_1a_0$ и $b_1b_0$:

$$
\begin{array}{cccc}
     &  & a_1 & a_0 \\
& \times  & b_1 & b_0 \\ \hline
  & & a_1 \cdot b_0 & a_0 \cdot b_0 \\
+ & a_1 \cdot b_1 & a_0 \cdot b_1 & \\ \hline
& a_1 \cdot b_1 & a_0 \cdot b_1 + a_1 \cdot b_0 & a_0 \cdot b_0 \\
\end{array}
$$

Например, для чисел $10$ и $11$ получится так:

$$
\begin{array}{cccc}
     &  & 1 & 0 \\
& \times  & 1 & 1 \\ \hline
  & & 1 & 0 \\
+ & 1 & 0 & \\ \hline
& 1 & 1 & 0 \\
\end{array}
$$

Очень удобно, что мы работаем с битовыми представлениями чисел.
Ведь тогда арифметическое умножение на однобитное число совпадает
с логическим умножением каждого бита на это однобитное число:
$a_1a_0 \times b_0 = a_1a_0\ \mbox{\&}\ b_0b_0$

Вычислить эти частичные произведения можно с помощью одного модуля
логических операций, так как он работает с четырьмя битами за раз.

Только сначала нужно <<размножить>> биты операнда $b$ с помощью коммутационной матрицы.

Выходы с модуля <<И>> нужно подать на сумматор. Только два бита
<<умноженные>> на $b_0$ остаются на месте и подаются на первый вход сумматора, а
<<умноженные>> на $b_1$ сдвигаются влево и подаются на второй вход.

Выход сумматора подключается в управляющим входам регистрового модуля, чтобы
пронаблюдать результат с помощью светодиодов в реле.
Получается такая схема:

\includegraphics[width=\columnwidth]{photo/multiply.jpg}

Попробуйте набирать с помощью тумблеров разные значения для обоих
операндов (конечно же, они должны быть от $0$ до $3$) и проверьте,
правильный ли получается результат.

% R = A * B
% R0 = A0 & B0
% R1 = A1 & B0
% R2 = A0 & B1
% R3 = A1 & B1
% R = R0 + (R1 + R2) << 1 + R3 << 2

% R = A & B0 + (A << 1) & B1
% R = R1R0 + R3R2<0>

% Логический модуль для AND
% Сумматор для получения результата
% Несколько модулей для замешивания битов


\section{Задачи}

\begin{enumerate}
    \item Собрать устройство для сложения значения из регистра с константой, набранной на тумблерах.
          Должна быть предусмотрена запись результата обратно в регистр.
          Дальше управлять сигналами таким образом, чтобы к регистру последовательно
          прибавлялась единица, пока он не достигнет значения $1111$.
          Тут необходимо использовать два регистровых модуля: из одного будет считываться операнд для сложения,
          а во второй записываться результат.
\end{enumerate}
